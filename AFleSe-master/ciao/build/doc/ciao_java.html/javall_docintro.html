<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" content="#273f79"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><script type="text/javascript" src="lpdoc-aux.js"></script><title>Introduction &mdash; Prolog/Java Bidirectional Interface</title></head><body><div class="lpdoc-page rightbar"><a href="#" id="sidebar-toggle-button" class="lpdoc-navbutton"><span id="sidebar-button-arrow">&#9776;</span></a><div id="sidebar" class="lpdoc-sidebar"><h2>Sections</h2><ul><li><a href="#Distributed Programming Model">Distributed Programming Model</a></li></ul><h2>Global Links</h2><ul><li><a href="javall_docfulltoc.html">Table of Contents</a></li><li><a href="javall_docrefs.html">References</a></li><li><a href="javall_doccopyright.html">Copyright</a></li></ul><h2>Indices</h2><ul><li><a href="javall_docliindex.html">Library/Module Index</a></li><li><a href="javall_docpdindex.html">Predicate/Method Index</a></li><li><a href="javall_docprindex.html">Property Index</a></li><li><a href="javall_docteindex.html">Regular Type Index</a></li><li><a href="javall_docdeindex.html">Declaration Index</a></li><li><a href="javall_doccoindex.html">Concept Index</a></li><li><a href="javall_docauindex.html">Author Index</a></li><li><a href="javall_docglindex.html">Global Index</a></li></ul></div><div class="lpdoc-main"><div class="lpdoc-nav"><span class="lpdoc-on-right"><a class="lpdoc-navbutton" href="javall_doc.html">&#x2191;</a><a class="lpdoc-navbutton" href="javall_docfulltoc.html">&#x2190;</a><a class="lpdoc-navbutton" href="javart.html">&#x2192;</a></span><span><a href="javall_doc.html">Prolog/Java Bidirectional Interface</a> &raquo; </span></div><div id=""><h1>Introduction</h1>
 <a class="lpdoc-idx-anchor" id="0" href="javall_doccoindex.html#Platform independence"></a> The increasing diversity of platforms used today and the diffusion of Internet and the World Wide Web makes compatibility between platforms a key factor to run the software everywhere with no change. Java seems to achieve this goal, using a bytecode intermediate language and a large library of platform-dependent and independent classes which fully implements many. On the other hand, Prolog provides a powerful implementation of logic programming paradigm. This document includes the reference manual of the Prolog/Java bidirectional interface implemented in Ciao. In addition, it has been developed an application of this interface that makes use of an object oriented extension of Prolog to encapsulate the java classes, O&apos;Ciao, both the ones defined in the JDK as well as new classes developed in Java. These classes can be used in the object oriented prolog extension of Ciao just like native O&apos;Ciao classes.<p>The proposed interaction between both languages is realized as an interface between two processes, a Java process and a Prolog process, running separately. This approach allows the programmer to use of both Java and Prolog, without the compiler-dependent glue code used in other linkage-oriented approaches, and preserves the philosophy of Java as an independent language. The interface communication is based on a clean socket-based protocol, providing hardware and software independence. This allows also both processes to be run in different machines connected by a TCP/IP transport protocol, based on a client/server model that can evolve to a more cooperative model.<p>The present manual includes reference information about the Prolog side of the bidirectional Java/Prolog interface. The Java side of this interface is explained in the HTML pages generated by Javadoc.<p><div id="Distributed Programming Model"><h2>Distributed Programming Model</h2> <a class="lpdoc-idx-anchor" id="1" href="javall_doccoindex.html#Distributed Programming Model"></a> The differences between Prolog and Java impose the division of the interface in two main parts: a prolog-to-java and a java-to-prolog interfaces. Most of the applications that will use this interface will consider that will be a &ldquo;client&apos; side that request actions and queries to a &ldquo;server&apos; side, which accomplish the actions and answer the queries. In a first approach, any of the both one-way interfaces implement a pure client/server model: the server waits for a query, performs the received query and sleeps until the next query comes; the client starts the server, carries out the initial part of the job initiating all the conversations with the server, and requests the server to do some things sometimes.<p>This model cannot handle correctly the tasks regarding an event oriented programming environment like java. A usual application of the prolog-to-java interface could be a graphical user interface server made in java, and a prolog client on the other side. A pure client/server model based on requests and results is not powerful enough to leave the prolog side managing all the application specific work of this example: some java specific stuff is needed to catch and manipulate properly the events thrown by the graphical user interface. This problem can be solved in a distributed context, on which both languages are clients and servers simultaneously, and can perform requests and do actions at a time. Using this model, the prolog side can add a prolog goal as listener of a specific event, and the java side launches that goal when the event raises.<p>In any case, the client/server approach simplifies the design of the interface, so both interfaces have been designed in such way, but keeping in mind that the goal is to reach a distributed environment, so each side do the things it is best designed for.<p></div><br/></div></div><div class="lpdoc-clearer"></div></div><div class="lpdoc-footer">Generated with LPdoc using Ciao</div></body></html>