
@node Java to Prolog interface, Low-level Prolog to Java socket connection, Prolog to Java interface, Top
@comment node-name, next, previous, up
@chapter Java to Prolog interface
@glindex jtopl
@liindex jtopl

@b{Author(s):} 
@glindex Jesus Correas
@auindex Jesus Correas
Jes@'us Correas.


 
@glindex Java to Prolog interface
@coindex Java to Prolog interface 
This module defines the Prolog side of the Java to Prolog interface. This side of the interface only has one public predicate: a server that listens at the socket connection with Java, and executes the commands received from the Java side.

In order to evaluate the goals received from the Java side, this module can work in two ways: executing them in the same engine, or starting a thread for each goal. The easiest way is to launch them in the same engine, but the goals must be evaluated sequentially: once a goal provides the first solution, all the subsequent goals must be finished before this goal can backtrack to provide another solution. The Prolog side of this interface works as a top-level, and the goals partially evaluated are not independent.

The solution of this goal dependence is to evaluate the goals in a different prolog engine. Although Ciao includes a mechanism to evaluate goals in different engines, the approach used in this interface is to launch each goal in a different thread.

The decision of what kind of goal evaluation is selected is done by the Java side. Each evaluation type has its own command terms, so the Java side can choose the type it needs.

A Prolog server starts by calling the @code{prolog_server/0} predicate, or by calling @code{prolog_server/1} predicate and providing the port number as argument. The user predicates and libraries to be called from Java must be included in the executable file, or be accesible using the built-in predicates dealing with code loading.


@section Usage and interface
@cartouche
@itemize @bullet
@item @b{Library usage:}

@code{:- use_module(library(javall/jtopl)).}
@item @b{Exports:}

@itemize @minus
@item @i{Predicates:}

@glindex prolog_server/0
@code{prolog_server/0}, 
@glindex prolog_server/1
@code{prolog_server/1}, 
@glindex prolog_server/2
@code{prolog_server/2}, 
@glindex shell_s/0
@code{shell_s/0}, 
@glindex query_solutions/2
@code{query_solutions/2}, 
@glindex query_requests/2
@code{query_requests/2}, 
@glindex running_queries/2
@code{running_queries/2}.
@end itemize
@end itemize
@end cartouche
@section Documentation on exports
@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{prolog_server/0 (pred)}}}
@temp
@end iftex
@glindex prolog_server/0
@pdindex prolog_server/0
@deffn PREDICATE prolog_server/0:

@b{Usage:} 

Prolog server entry point. Reads from the standard input the node name and port number where the java client resides, and starts the prolog server listening at the jp socket. This predicate acts as a server: it includes an endless read-process loop until the @code{prolog_halt} command is received.

However, from the low-level communication point of view, this Prolog server actually works as a client of the Java side. This means that Java side waits at the given port to a Prolog server trying to create a socket; Prolog side connects to that port, and then waits for Java requests (acting as a 'logical' server). To use this Prolog server as a real server waiting for connections at a given port, use @code{prolog_server/1}.

@glindex Prolog server
@coindex Prolog server 
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{prolog_server/1 (pred)}}}
@temp
@end iftex
@glindex prolog_server/1
@pdindex prolog_server/1
@deffn PREDICATE prolog_server/1:

@b{Usage:} 

Waits for incoming Java connections to act as a Prolog goal server for Java requests.This is the only @code{prolog_server/*} predicate that works as a true server: given a port number, waits for a connection from Java and then serves Java requests. When a termination request is received, finishes the connection to Java and waits next Java connection request. This behaviour is different with respect to previous versions of this library. To work as before, use @code{prolog_server/2}.

Although it currently does not support simultaneous Java connections, some work is being done in that direction. 
@glindex Prolog server
@coindex Prolog server 
@itemize @minus
@item @i{Call and exit should be compatible with:}

@code{Arg1} is an atom.
@iftex
@hfill
@end iftex
 (@code{basic_props:atm/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{prolog_server/2 (pred)}}}
@temp
@end iftex
@glindex prolog_server/2
@pdindex prolog_server/2
@deffn PREDICATE prolog_server/2:

@b{Usage:} 

Prolog server entry point. Given a network @code{node} and a @code{port} number, starts the prolog server trying to connect to Java side at that @code{node:port} address, and then waits for Java requests. This predicate acts as a server: it includes an endless read-process loop until the @code{prolog_halt} command is received.

However, from the low-level communication point of view, this Prolog server actually works as a client of the Java side. This means that Java side waits at the given port to a Prolog server trying to create a socket; Prolog side connects to that port, and then waits for Java requests (acting as a 'logical' server). To use this Prolog server as a real server waiting for connections at a given port, use @code{prolog_server/1}. 
@glindex Prolog server
@coindex Prolog server 
@itemize @minus
@item @i{Call and exit should be compatible with:}

@code{Arg1} is an atom.
@iftex
@hfill
@end iftex
 (@code{basic_props:atm/1})

@code{Arg2} is an atom.
@iftex
@hfill
@end iftex
 (@code{basic_props:atm/1})
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{shell_s/0 (pred)}}}
@temp
@end iftex
@glindex shell_s/0
@pdindex shell_s/0
@deffn PREDICATE shell_s/0:

@b{Usage:} 

Command execution loop. This predicate is called when the connection to Java is established, and performs an endless loop processing the commands received. This predicate is only intended to be used by the Prolog to Java interface and it should not be used by a user program.
@itemize @minus
@end itemize
@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{query_solutions/2 (pred)}}}
@temp
@end iftex
@glindex query_solutions/2
@pdindex query_solutions/2
@deffn PREDICATE query_solutions/2:
No further documentation available for this predicate.
The predicate is of type @i{concurrent}.

@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{query_requests/2 (pred)}}}
@temp
@end iftex
@glindex query_requests/2
@pdindex query_requests/2
@deffn PREDICATE query_requests/2:
No further documentation available for this predicate.
The predicate is of type @i{concurrent}.

@end deffn
@sp 1

@iftex
@edef@temp{@noexpand@writetocentry{@realbackslash unnumbsubsubsecentry{running_queries/2 (pred)}}}
@temp
@end iftex
@glindex running_queries/2
@pdindex running_queries/2
@deffn PREDICATE running_queries/2:
No further documentation available for this predicate.
The predicate is of type @i{concurrent}.

@end deffn
@sp 1

@section Documentation on imports
This module has the following direct dependencies:
@itemize @minus
@item @i{Application modules:}

@glindex javasock
@code{javasock}.
@item @i{System library modules:}

@glindex datafacts_rt
@code{datafacts_rt}, 
@glindex concurrency
@code{concurrency}, 
@glindex system
@code{system}, 
@glindex read
@code{read}, 
@glindex compiler
@code{compiler}, 
@glindex read_from_string
@code{read_from_string}.
@item @i{Packages:}

@glindex prelude
@code{prelude}, 
@glindex initial
@code{initial}, 
@glindex condcomp
@code{condcomp}, 
@glindex assertions
@code{assertions}, 
@glindex assertions/assertions_basic
@code{assertions/assertions_basic}, 
@glindex regtypes
@code{regtypes}, 
@glindex isomodes
@code{isomodes}, 
@glindex datafacts
@code{datafacts}.
@end itemize
